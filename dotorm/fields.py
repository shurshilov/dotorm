import datetime
from decimal import Decimal as PythonDecimal
import logging
from typing import TYPE_CHECKING, Any, Type

if TYPE_CHECKING:
    from .orm import DotModel


log = logging.getLogger("dotorm")
from .exceptions import OrmConfigurationFieldException


class Field[FieldType]:
    """
    sql_type - DB Field types for default
    indexable - Is the field can be indexed?
    store - Is the field generated by the DB?

    index - Is the field indexed?
    primary_key - Is the field primary_key?
    null - Is the column nullable?
    unique - Is the field unique?
    description - Description of the field (nullable)
    default - The default value (coerced to int/float/str/bool/null)

    relation - Field one2one one2many or many2many?
    relation_table - str table name of related model
    relation_table_field - str table field name of related model

    Raises:
    OrmConfigurationFieldException: _description_
    OrmConfigurationFieldException: _description_

    """

    # __slots__ = ('python_type',
    #             'pydantic_type',
    #             'store',
    #             'default'
    #             )
    sql_type: str
    indexable: bool = False
    store: bool = True

    index: bool = False
    primary_key: bool = False
    null: bool = True
    unique: bool = False
    description: str | None = None
    default: FieldType | None = None

    ondelete: str = "set null"
    relation: bool = False
    relation_table_field: str | None = None

    def __init__(self, **kwargs: Any) -> None:
        self.indexable = kwargs.pop("indexable", False)
        self.store = kwargs.pop("store", True)
        self.primary_key = kwargs.pop("primary_key", False)
        self.null = kwargs.pop("null", True)
        self.unique = kwargs.pop("unique", False)
        self.description = kwargs.pop("description", None)
        self.default = kwargs.pop("default", None)
        # self.ondelete = "restrict" if self.required else "set null"
        self.ondelete = "set null" if self.null else "restrict"

        for name, value in kwargs.items():
            setattr(self, name, value)
        self.validation()

    # обман тайп чекера.
    # TODO: В идеале, сделать так чтобы тип поля менялся если это обьект и если это класс.
    # 1. Возможно это необходимо сделать в классе скорей всего модели
    # 2. Или перейти на pep-0593 (Integer = Annotated[int, Integer(primary_key=True)])
    # но тогда в классе не будет типа Field и мы получим такую же ситуаци но в классе
    def __new__(cls, *args: Any, **kwargs: Any) -> FieldType:
        return super().__new__(cls)

    def validation(self):
        # if self.ondelete == 'set null' and self.required:
        if not self.indexable and (self.unique or self.index):
            raise OrmConfigurationFieldException(
                f"{self.__class__.__name__} can't be indexed"
            )

        if self.primary_key:
            # UNIQUE or PRIMARY KEY constraint to prevent duplicate values
            self.unique = True

            if self.sql_type == "INTEGER":
                self.sql_type = "SERIAL"
            elif self.sql_type == "BIGINT":
                self.sql_type = "BIGSERIAL"
            elif self.sql_type == "SMALLINT":
                self.sql_type = "SMALLSERIAL"
            else:
                raise OrmConfigurationFieldException(
                    f"{self.__class__.__name__} primary_key supported only for integer, bigint, smallint fields"
                )

            if not self.store:
                raise OrmConfigurationFieldException(
                    f"{self.__class__.__name__} primary_key required store db"
                )
            if self.null:
                log.debug(
                    f"{self.__class__.__name__} can't be both null=True and primary_key=True. Null will be ignored."
                )
                self.null = False
            if self.index:
                # self.index = False
                raise OrmConfigurationFieldException(
                    f"{self.__class__.__name__} can't be both index=True and primary_key=True. Primary key have index already."
                )
            # первичный ключ уже автоинкрементируется как SERIAL и имеет значение по умолчанию
            # DEFAULT nextval('tablename_colname_seq')
            if self.default:
                # self.default = None
                raise OrmConfigurationFieldException(
                    f"{self.__class__.__name__} can't be both default=True and primary_key=True. Primary key autoincrement already."
                )

        if self.unique:
            if self.index:
                # self.index = False
                raise OrmConfigurationFieldException(
                    f"{self.__class__.__name__} can't be both index=True and unique=True. Index will be ignored."
                )

    @property
    def required(self) -> bool:
        """
        Returns ``True`` if the field is required to be provided.

        It needs to be non-nullable and not have a default or be DB-generated to be required.
        """
        # return self.default is None and not self.null and not self.store
        return not self.null

    @property
    def relation_table(self):
        if callable(self._relation_table):
            return self._relation_table()
        return self._relation_table

    @relation_table.setter
    def relation_table(self, table):
        self._relation_table = table


class Integer(Field[int]):
    """
    Integer field. (32-bit signed)

    ``primary_key`` (bool):
        True if field is Primary Key.
    """

    field_type = int
    sql_type = "INTEGER"

    # @property
    # def sql_type(self) -> str:
    #     return "SERIAL"

    # class _db_postgres:
    #     GENERATED_SQL = "SERIAL NOT NULL PRIMARY KEY"

    # class _db_mysql:
    #     GENERATED_SQL = "INT NOT NULL PRIMARY KEY AUTO_INCREMENT"


class BigInteger(Field[int]):
    """
    Big integer field. (64-bit signed)

    ``primary_key`` (bool):
        True if field is Primary Key.
    """

    sql_type = "BIGINT"

    # class _db_postgres:
    #     GENERATED_SQL = "BIGSERIAL NOT NULL PRIMARY KEY"

    # class _db_mysql:
    #     GENERATED_SQL = "BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT"


class SmallInteger(Field[int]):
    """
    Small integer field. (16-bit signed)

    ``primary_key`` (bool):
        True if field is Primary Key.
    """

    sql_type = "SMALLINT"

    # class _db_postgres:
    #     GENERATED_SQL = "SMALLSERIAL NOT NULL PRIMARY KEY"

    # class _db_mysql:
    #     GENERATED_SQL = "SMALLINT NOT NULL PRIMARY KEY AUTO_INCREMENT"


class Char(Field[str]):
    """
    Character field.

    You must provide the following:

    ``max_length`` (int):
        Maximum length of the field in characters.
    """

    field_type = str

    def __init__(self, max_length: int, **kwargs: Any) -> None:
        if int(max_length) < 1:
            raise OrmConfigurationFieldException("'max_length' must be >= 1")
        self.max_length = int(max_length)
        super().__init__(**kwargs)

    @property
    def sql_type(self) -> str:
        return f"VARCHAR({self.max_length})"


class Text(Field[str]):  # type: ignore
    """
    Large Text field.
    """

    field_type = str
    indexable = False
    sql_type = "TEXT"

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        if self.unique:
            raise OrmConfigurationFieldException(
                "TextField doesn't support unique indexes, consider CharField or another strategy"
            )
        if self.index:
            raise OrmConfigurationFieldException(
                "TextField can't be indexed, consider CharField"
            )

    class _db_mysql:
        sql_type = "LONGTEXT"


class Boolean(Field[bool]):
    """
    Boolean field.
    """

    field_type = bool
    sql_type = "BOOL"


class Decimal(Field[PythonDecimal]):
    """
    Accurate decimal field.

    You must provide the following:

    """

    def __init__(self, max_digits: int, decimal_places: int, **kwargs: Any) -> None:
        if int(max_digits) < 1:
            raise OrmConfigurationFieldException("'max_digits' must be >= 1")
        if int(decimal_places) < 0:
            raise OrmConfigurationFieldException("'decimal_places' must be >= 0")

        self.max_digits = int(max_digits)
        self.decimal_places = int(decimal_places)
        super().__init__(**kwargs)

    @property
    def sql_type(self) -> str:  # type: ignore
        return f"DECIMAL({self.max_digits},{self.decimal_places})"


class Datetime(Field[datetime.datetime]):
    """
    Datetime field.

    """

    sql_type = "TIMESTAMPTZ"

    class _db_mysql:
        sql_type = "DATETIME(6)"

    class _db_postgres:
        sql_type = "TIMESTAMPTZ"


class Date(Field[datetime.date]):
    """
    Date field.
    """

    sql_type = "DATE"


class Time(Field[datetime.time]):
    """
    Time field.
    """

    sql_type = "TIME"

    class _db_mysql:
        sql_type = "TIME(6)"

    class _db_postgres:
        sql_type = "TIMETZ"


class Float(Field[float]):
    """
    Float (double) field.
    """

    sql_type = "DOUBLE PRECISION"

    class _db_mysql:
        sql_type = "DOUBLE"


class JSONField(Field[dict | list]):
    """
    JSON field.

    """

    sql_type = "JSONB"
    indexable = False

    class _db_mysql:
        sql_type = "JSON"


# class Relation: ...


class Many2one[T: "DotModel"](Field[T]):
    """
    Many2one field.
    """

    field_type = Type
    sql_type = "INTEGER"
    relation = True

    def __init__(self, relation_table: Type, **kwargs: Any) -> None:
        self._relation_table = relation_table
        super().__init__(**kwargs)


class Many2many[T: "DotModel"](Field[list[T]]):
    """
    Many2many field.
    """

    field_type = list[Type]
    store = False
    relation = True

    def __init__(
        self,
        relation_table: T,
        many2many_table: str,
        column1: str,
        column2: str,
        **kwargs: Any,
    ) -> None:
        self.relation_table = relation_table
        self.many2many_table = many2many_table
        self.column1: str = column1
        self.column2 = column2
        super().__init__(**kwargs)


class One2many[T: "DotModel"](Field[list[T]]):
    """
    One2many field.
    """

    field_type = list[Type]
    store = False
    relation = True

    def __init__(
        self,
        relation_table: T,
        relation_table_field: str,
        **kwargs: Any,
    ) -> None:
        self._relation_table = relation_table
        self.relation_table_field = relation_table_field
        super().__init__(**kwargs)


class One2one[T: "DotModel"](Field[T]):
    """
    One2one field.
    """

    field_type = Type
    store = False
    relation = True

    def __init__(
        self,
        relation_table: T,
        relation_table_field: str,
        **kwargs: Any,
    ) -> None:
        self.relation_table = relation_table
        self.relation_table_field = relation_table_field
        super().__init__(**kwargs)
